[["index.html", "Introduction to statistical data analysis in R About Workshop structure", " Introduction to statistical data analysis in R Mario Recker About This workshop is intended to introduce the R/RStudio statistical programming environment and how to use it for efficient data handling, data visualisation and data analysis. It is aimed at individuals with little experience in R/Rstudio and basic statistics. For those who are interested in a general intro to R or a refresher, please have a look at the following site for a great introduction to R/RStudio Introduction to R. Equally, much of the material on statistical data analysis are based on the Statistical Modelling in R workshop. These workshops had been developed by TJ McKinley from the University of Exeter and JJ Valletta (\\(\\dagger\\)). Workshop structure This workshop will loosely be structured into the following themes Data handling importing data data types missing data Descriptive statistics summary statistics contingency tables graphical representation Inferential statistics linear models mixed effect models generalised linear models survivial analysis Latent Class Analysis \\(~\\) The workshop will consist of a mixture between (theoretical) background and hands-on practicals. Specific tasks, designed for you to test your new skills and understanding, are highlighted as Task This task will be explained here The solution can be revealed by clicking Show: Solution Solution A solution will appear here. However, please make sure you try before clicking on the Solution - this is the only way to make sure how fully understood the new concepts. \\(~\\) Prerequisites It is expected that you feel comfortable with basic R / RStudio and, specifically, the use of data.frame objects. The Appendix provides extra background material, covering a lot of necessary background. Also, for this workshop we will be relying on the tidyverse package, or rather suite of packages for performing a (growing) number of data science tasks, which include ggplot2 and dplyr. Please have a look in the Appendix for a brief introduction to their uses. \\(~\\) Important There will be plenty of time to practice your new skills, and please feel to aks if anything is not 100% clear. "],["data-handling.html", "1 Data handling Importing data Data types Missing data", " 1 Data handling Importing data An essential part of data analysis is the ability to read (and store) external datasets. There are a myriad of different ways this can be done in R, partially depending on the file type / software originally used to store the data. Here we focus on three different file formats: CSV files (filename.csv) Excel files (filename.xls or filename.xlsx) R data format (filename.rds or filename.RData) The main difference between the approaches is that an Rds file stores data in a (R specific) binary format, meaning that you need R to read it. The same goes for Excel files. CSV files, in comparison, are (human readable) text files that can be opened by a number of different programs. In fact, on most operating systems, these are opened by Excel or a text editor by default. The decision which approach you should use often depends on whether you are the only one working with the data or whether you like the added benefit of viewing (or manipulating) data outside the R environment. Note: Excel is known to occasionally cause havoc with data (mostly due to it changing data types by itself), we are urging caution when handling Excel files. Always check the validity of your data before starting with your analysis! CSV files CSV (Comma-Separated Values) is a widely used data format separating values with commas or other delimiters (e.g. semi-colon or tab). There are different function pairs for reading CSV files, such as the inbuilt read.table() or read.csv(), and their equivalent functions for writing CSV files. Here we will use the read_csv() function, which is part of the readr package (included in tidyverse). Note: this function is strictly for comma-separated files, read_csv2() reads semicolon-separated and the read_delim() function reads files with any separating character; for full fucntion details, see [here] (https://www.rdocumentation.org/packages/readr/versions/2.1.5/topics/read_delim). As an example we will be using the tobacco.csv file that contains a simulated dataset on tobacco use and health of 1000 individuals. Please make sure that the file is contained in your current working directory. tobacco &lt;- read.csv(&#39;tobacco.csv&#39;) Check if this worked by printing out the first 5 rows head(tobacco, n = 5) ## gender age age.gr BMI smoker cigs.per.day diseased disease ## 1 M 75 71 + 29.50225 No 0 No &lt;NA&gt; ## 2 F 35 35-50 26.14989 No 0 Yes Neurological ## 3 F 70 51-70 27.53183 No 0 No &lt;NA&gt; ## 4 F 40 35-50 24.05832 No 0 No &lt;NA&gt; ## 5 F 75 71 + 22.77486 No 0 Yes Hearing ## samp.wgts ## 1 1.062500 ## 2 1.044177 ## 3 1.049383 ## 4 1.044177 ## 5 1.062500 In an equivalent fashion we can save data in CSV format using the write_csv() function. write_csv(tobacco, &quot;myData.csv&quot;) # make sure you do not overwrite the original data file!! Excel files Although we discourage the use of Excel for data handling, it is still one of the most common methods for storing data. We therefore briefly show you one method of how to read Excel files using the read_excel function from the readxl package. NOTE: although readxl will be installed as part of tidyverse, you will still need to load it explicitly, because it is not a core tidyverse package. # load library library(readxl) # read in excel data file tobaccoXLS &lt;- read_excel(&#39;tobacco.xlsx&#39;) # print first few rows head(tobaccoXLS, n = 5) ## # A tibble: 5 × 9 ## gender age age.gr BMI smoker cigs.per.day diseased disease samp.wgts ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 M 75 71 + 29.5022463… No 0 No NA 1.06 ## 2 F 35 35-50 26.1498941… No 0 Yes Neurol… 1.04 ## 3 F 70 51-70 27.5318291… No 0 No NA 1.05 ## 4 F 40 35-50 24.0583177… No 0 No NA 1.04 ## 5 F 75 71 + 22.7748622… No 0 Yes Hearing 1.06 This functions offers a great deal of flexibility, from specifying which sheet to import (by default it will import the first one), specifying the data range, or repairing column names for easier downstream analysis. # specify the name of the sheet and only load the first 100 rows and 7 columns tobaccoXLS &lt;- read_excel(&#39;tobacco.xlsx&#39;, sheet = &#39;tobacco_2&#39;, range = &#39;A1:G101&#39;) ## which is equivalent to # dat &lt;- read_excel(&#39;tobacco.xlsx&#39;, range = &#39;tobacco_2!A1:G101&#39;) # check the first 5 rows head(tobaccoXLS, n = 5) ## # A tibble: 5 × 7 ## gender age `age group` BMI smoker `cigarettes per day` diseased ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 M 75 71 + 29.5 No 0 No ## 2 F 35 35-50 26.1 No 0 Yes ## 3 F 70 51-70 27.5 No 0 No ## 4 F 40 35-50 24.1 No 0 No ## 5 F 75 71 + 22.8 No 0 Yes We can see that two column names contain spaces, which can make life a bit tricky during subsequent operations. For this, read_excel provides a .name_repair argument, that ensures column names will be syntactic (not containing special characters or reserved words) and work everywhere. (Note: this argument can also be used in the read_csv() function.) tobaccoXLS &lt;- read_excel(&#39;tobacco.xlsx&#39;, sheet = &#39;tobacco_2&#39;, range = &#39;A1:G101&#39;, .name_repair = &#39;universal&#39;) ## New names: ## • `age group` -&gt; `age.group` ## • `cigarettes per day` -&gt; `cigarettes.per.day` head(tobaccoXLS, n = 5) ## # A tibble: 5 × 7 ## gender age age.group BMI smoker cigarettes.per.day diseased ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 M 75 71 + 29.5 No 0 No ## 2 F 35 35-50 26.1 No 0 Yes ## 3 F 70 51-70 27.5 No 0 No ## 4 F 40 35-50 24.1 No 0 No ## 5 F 75 71 + 22.8 No 0 Yes A really handy cheatsheet for importing data with the tidyverse can be found here R data files To demonstrate the use of R data file format, we go the other way around and start by saving our tobacco dataframe as an R object. saveRDS(tobacco, file = &#39;tobacco.Rds&#39;) Note: the file will be saved in your current working directory. If you want to save it in a different folder you need to provide the full file path, e.g. saveRDS(df, file = '.../StatsWithR//Data/myData.Rds'). Loading the data is equally simple: # first we remove the tobacco data object to make sure everything works rm(tobacco) # load the data readRDS(&#39;tobacco.Rds&#39;) ## gender age age.gr BMI smoker cigs.per.day diseased disease ## 1 M 75 71 + 29.502246 No 0 No &lt;NA&gt; ## 2 F 35 35-50 26.149894 No 0 Yes Neurological ## 3 F 70 51-70 27.531829 No 0 No &lt;NA&gt; ## 4 F 40 35-50 24.058318 No 0 No &lt;NA&gt; ## 5 F 75 71 + 22.774862 No 0 Yes Hearing ## 6 M 38 35-50 21.464121 No 0 No &lt;NA&gt; ## 7 M 45 35-50 18.948411 No 0 No &lt;NA&gt; ## 8 &lt;NA&gt; 59 51-70 30.376773 No 0 No &lt;NA&gt; ## 9 F 29 18-34 21.408103 Yes 38 No &lt;NA&gt; ... At first sight this looks like it has worked. However, you might also have noticed that there is no newly created object in your global environment. This means, although R successfully loaded the data, it was not assigned to an object and essentially lost; this is one of the key differences between saveRDS/readRDS and save/load (see below)). We therefore need to assign the read-in data to an object # read data and assign to an object called tobacco tobacco &lt;- readRDS(&#39;tobacco.Rds&#39;) # see if it works head(tobacco) ## gender age age.gr BMI smoker cigs.per.day diseased disease ## 1 M 75 71 + 29.50225 No 0 No &lt;NA&gt; ## 2 F 35 35-50 26.14989 No 0 Yes Neurological ## 3 F 70 51-70 27.53183 No 0 No &lt;NA&gt; ## 4 F 40 35-50 24.05832 No 0 No &lt;NA&gt; ## 5 F 75 71 + 22.77486 No 0 Yes Hearing ## 6 M 38 35-50 21.46412 No 0 No &lt;NA&gt; ## samp.wgts ## 1 1.062500 ## 2 1.044177 ## 3 1.049383 ## 4 1.044177 ## 5 1.062500 ## 6 1.044177 An alternative way is the use of the Rdata file format. # save our dataframe in Rdata format save(tobacco, file = &quot;tobacco.Rdata&quot;) # remove from our environment rm(tobacco) # load the data load(&quot;tobacco.Rdata&quot;) As you will have noticed, in this case we do not need to explicitly assign the loaded data to object; instead, the original name of the dataframe will be used. Another advantage of using this format is that we can save multiple objects at once # save both dataframe in one file save(tobacco, tobaccoXLS, file = &#39;tobacco_datasets.Rda&#39;) # remove from environment rm(tobacco, tobaccoXLS) # load the data load(&#39;tobacco_datasets.Rda&#39;) One of the advantages of saving data in an R data format is that it is more space efficient. By default, saveRDS() (or save()) compresses the data, which can significantly shrink the size of the stored data. On the downside, it can also take a bit longer to load the data subsequently. Data types Although we assume that you are likely already familiar with different types of data, this is just a reminder of the most common data types in R numeric / integer character factor logical We have already come across some of them when we imported the tobacco data in the previous section. To check what types of data are contained in this dataset we can use the class() function; for example # get the data type of column &#39;gender&#39; class(tobacco$gender) ## [1] &quot;character&quot; # get the data type of column &#39;BMI&#39; class(tobacco$BMI) ## [1] &quot;numeric&quot; Instead of doing this for every column separately, we can apply this function across the whole dataframe with sapply sapply(tobacco, class) ## gender age age.gr BMI smoker cigs.per.day ## &quot;character&quot; &quot;integer&quot; &quot;character&quot; &quot;numeric&quot; &quot;character&quot; &quot;integer&quot; ## diseased disease samp.wgts ## &quot;character&quot; &quot;character&quot; &quot;numeric&quot; Here’s a brief overview of what these data types are and what they are generally used for. Numeric / integer A variable will be automatically stored as numeric data if the values are numbers or contain decimals. Depending on the function used to import data, a variable can also be assigned explicitly as integer if it does not contain any decimals. # define a vector of three numerical values x &lt;- c(4, 3, 5) # get the data type class(x) ## [1] &quot;numeric&quot; # compare to the imported data column &#39;age&#39; class(tobacco$age) ## [1] &quot;integer&quot; We can also force R to convert a numeric variable into an integer, and vice versa x &lt;- as.integer(x) class(x) ## [1] &quot;integer&quot; tobacco$age &lt;- as.numeric(tobacco$age) class(tobacco$age) ## [1] &quot;numeric&quot; Character Character is the general data type to store text (strings), such as words, sentences etc. # first example a &lt;- &quot;this is a character data type&quot; class(a) ## [1] &quot;character&quot; # second example b &lt;- &quot;1&quot; # enclosing a number in quotes will define it as a character type class(b) ## [1] &quot;character&quot; # type conversion from numeric to character c &lt;- 12.3 d &lt;- as.character(c) class(d) ## [1] &quot;character&quot; # automatic &#39;conversion&#39; v &lt;- c(1, 2, 3, &quot;4&quot;) class(v) ## [1] &quot;character&quot; Factor At a first glance, factor variables look very similar to character types. However, factors are used to denote categorical variables, i.e. those that can only take a (pre-determined) limited number of values. # convert v into a categorical variable f1 &lt;- factor(v) # printing it will already reveal the difference to v as the factor levels are provided alongside the values f1 ## [1] 1 2 3 4 ## Levels: 1 2 3 4 # this works also on numeric variables f2 &lt;- factor(c(1, 2, 3, 4)) f2 ## [1] 1 2 3 4 ## Levels: 1 2 3 4 Looking at our tobacco dataframe we can see that some columns denote categorical variables (gender, age group, smoker, diseased and disease) and should be converted accordingly, which can be done either using the function as.factor() or just factor(). Here we will use dplyr’s mutate() function to convert all five columns simultaneously. tobacco &lt;- tobacco %&gt;% mutate(gender = factor(gender), age.gr = factor(age.gr), smoker = factor(smoker), diseased = factor(diseased), disease = factor(disease)) # check if this worked sapply(tobacco, class) ## gender age age.gr BMI smoker cigs.per.day ## &quot;factor&quot; &quot;numeric&quot; &quot;factor&quot; &quot;numeric&quot; &quot;factor&quot; &quot;integer&quot; ## diseased disease samp.wgts ## &quot;factor&quot; &quot;factor&quot; &quot;numeric&quot; Logical Logical variables can only take on two values&gt; TRUE and FALSE (which can also be abbreviated as T and F, respectively). These are common data types when used with logical operation, e.g. x &lt;- 5 y &lt;- 7 x &gt; y # read is &#39;is x greater than y&#39; ## [1] FALSE or if(x &gt; y){ print(&quot;x is greater than y&quot;) }else{ print(&quot;x is not greater than y&quot;) } ## [1] &quot;x is not greater than y&quot; Furthermore, a logical TRUE can be numerically interpreted as 1 and a FALSE as 0. as.integer(x &lt; y) ## [1] 1 This fact can be used in a variety of cases, as shown in the example below (try to understand what exactly is going on) # define a vector with 15 elements v &lt;- c(2, 6, 4, 8, 7, 8, 4, 1, 5, 8, 2, 9, 11, 4, 7) # are the elements less than or equal to 5 v &lt;= 5 ## [1] TRUE FALSE TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE TRUE FALSE ## [13] FALSE TRUE FALSE # how many elements are less than or equal to 5 sum(v &lt;= 5) ## [1] 7 Missing data More often than not we will find ourselves confronted with datasets that are not complete. That is, some information might be missing for some of the variables, and we need to find a way to deal with those cases. In R, missing values are usually represented by NA. Note: when importing data we can specify the value or symbol used to represent missing data. We can test for the presence of missing values using the is.na() function v &lt;- c(1, 4, 2, NA, 8, 9) is.na(v) ## [1] FALSE FALSE FALSE TRUE FALSE FALSE which confirms that there is a missing number between elements 3 and 5. To find the exact location we could use which(is.na(v)) ## [1] 4 The is.na() function can also be applied to data frames, as shown below is.na(tobacco) ## gender age age.gr BMI smoker cigs.per.day diseased disease ## [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [2,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [3,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [4,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [5,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [6,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [7,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [8,] TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [9,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ... and in combination with some other functions can be used to get crucial information about the degree of missingness in our data # count the number of missing entries in each column and convert to percentage 100 * colSums(is.na(tobacco)) / nrow(tobacco) ## gender age age.gr BMI smoker cigs.per.day ## 2.2 2.5 2.5 2.6 0.0 3.5 ## diseased disease samp.wgts ## 0.0 77.8 0.0 The big question always comes down to how to deal with missing data. The easiest approach is to just delete / ignore those cases, and there are two commonly used ways of doing this, with na.omit() or complete.cases(). The first function returns an object with all missing values removed # create a new data frame based on tobacco with all rows removed that contain NAs tobacco_noNAs &lt;- na.omit(tobacco) head(tobacco_noNAs, 10) ## gender age age.gr BMI smoker cigs.per.day diseased disease ## 2 F 35 35-50 26.14989 No 0 Yes Neurological ## 5 F 75 71 + 22.77486 No 0 Yes Hearing ## 15 M 47 35-50 29.04873 Yes 21 Yes Musculoskeletal ## 16 M 76 71 + 23.13594 Yes 29 Yes Vision ## 20 M 73 71 + 26.73234 No 0 Yes Heart ## 22 F 28 18-34 23.52206 Yes 15 Yes Cancer ## 24 F 80 71 + 26.31107 No 0 Yes Hypertension ## 29 F 68 51-70 27.20262 No 0 Yes Musculoskeletal ## 32 F 71 71 + 26.82957 No 0 Yes Neurological ## 39 F 22 18-34 21.23634 Yes 34 Yes Heart ## samp.wgts ## 2 1.0441767 ## 5 1.0625000 ## 15 1.0441767 ## 16 1.0625000 ## 20 1.0625000 ## 22 0.8614232 ## 24 1.0625000 ## 29 1.0493827 ## 32 1.0625000 ## 39 0.8614232 The other option is to use the comple.cases() function, which returns a logical vector indicating which rows contain no missing values (returned as TRUE) complete.cases(tobacco) ## [1] FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE TRUE TRUE FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE ## [25] FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE ## [37] FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE ## [49] TRUE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE TRUE ## [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [73] FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## [85] FALSE FALSE FALSE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE FALSE ## [97] FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE ## [109] FALSE TRUE TRUE TRUE TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ... and this can then be used to subset the data, i.e. we select only those rows that have full information for all variables tobacco_noNAs &lt;- tobacco[complete.cases(tobacco),] head(tobacco_noNAs, 10) ## gender age age.gr BMI smoker cigs.per.day diseased disease ## 2 F 35 35-50 26.14989 No 0 Yes Neurological ## 5 F 75 71 + 22.77486 No 0 Yes Hearing ## 15 M 47 35-50 29.04873 Yes 21 Yes Musculoskeletal ## 16 M 76 71 + 23.13594 Yes 29 Yes Vision ## 20 M 73 71 + 26.73234 No 0 Yes Heart ## 22 F 28 18-34 23.52206 Yes 15 Yes Cancer ## 24 F 80 71 + 26.31107 No 0 Yes Hypertension ## 29 F 68 51-70 27.20262 No 0 Yes Musculoskeletal ## 32 F 71 71 + 26.82957 No 0 Yes Neurological ## 39 F 22 18-34 21.23634 Yes 34 Yes Heart ## samp.wgts ## 2 1.0441767 ## 5 1.0625000 ## 15 1.0441767 ## 16 1.0625000 ## 20 1.0625000 ## 22 0.8614232 ## 24 1.0625000 ## 29 1.0493827 ## 32 1.0625000 ## 39 0.8614232 Although this works, there are two major issues with this approach data loss data bias If you compare the original dataset with the reduced one you will notice two things: first, it is much smaller (203 observations compared to 1000), which is a reduction by over 70% even though only one of the variables contains more than 4% missing data; and second, the data now only contains observation of those individuals who are diseased, which would obviously bias our downstream analysis. Omitting missing data should thus only be done in exceptional circumstances and with great caution. The safer, alternative strategies are either data imputation, which essentially tries to guess the missing values based on other information contained in the data (this is not covered as part of this workshop, but if you are interested you could have a look at this site), or simply ignoring the missing data and relying on the fact that most R functions have their own way of dealing with missing values; e.g. compare # sum over all elements in v produces NA sum(v) ## [1] NA with # telling sum() to ignore, or remove NA&#39;s, solves this issue sum(v, na.rm = TRUE) ## [1] 24 Beware: different functions have different default settings when it comes to handling NA’s; always look in the help file to make sure they do what you want them to do! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
